#' Copy from clipboard as a vector
#'
#' @return
#' @export
#'
#' @examples
CIP <- function() {
  #  this is entirely yoinked from clipr package and renamed
  # Determine system type
  sys.type <- sys_type()
  
  # Use the appropriate handler function
  chosen_read_clip <- switch(sys.type,
                             "Darwin" = osx_read_clip,
                             "Windows" = win_read_clip,
                             X11_read_clip
  )
  
  content <- chosen_read_clip()
  
  if (length(content) == 0) {
    warning("System clipboard contained no readable text. Returning NULL.")
    return(NULL)
  }
  
  content
}


#' Paste to clipboard
#'
#' @param content 
#' @param object_type 
#' @param breaks 
#' @param eos 
#' @param return_new 
#' @param allow_non_interactive 
#' @param ... 
#'
#' @return
#' @export
#'
#' @examples
COUT <- function(content, object_type = c("auto", "character", "table"),
                       breaks = NULL, eos = NULL, return_new = FALSE,
                       allow_non_interactive = Sys.getenv("CLIPR_ALLOW", interactive()), ...) {
  if (allow_non_interactive != "TRUE") warn_interactive()
  
  object_type <- match.arg(object_type)
  # Determine system type
  sys.type <- sys_type()
  
  # Choose an operating system-specific function (stop with error if not
  # recognized)
  chosen_write_clip <- switch(sys.type,
                              "Darwin" = osx_write_clip,
                              "Windows" = win_write_clip,
                              X11_write_clip
  )
  
  # Supply the clipboard content to write and options list to this function
  invisible(chosen_write_clip(content, object_type, breaks, eos, return_new, ...))
}

#' Clear clipboard
#'
#' Clear the system clipboard.
#'
#' @param \ldots Pass other options to [write_clip()].
#'
#' @note This is a wrapper function for `write_clip("")`
#'
#' @export
clear_clip <- function(...) {
  write_clip(content = "", ...)
}

#' Write contents of the last R expression to the clipboard
#'
#' @param \ldots Pass other options to [write_clip()].
#'
#' @note This is a wrapper function for `write_clip(.Last.value)`
#' @export
write_last_clip <- function(...) {
  write_clip(.Last.value, ...)
}


# Helper function to read from the OS X clipboard
# Adapted from https://github.com/jennybc/reprex/blob/master/R/clipboard.R
osx_read_clip <- function() {
  con <- pipe("pbpaste")
  content <- scan(con, what = character(), sep = "\n",
                  blank.lines.skip = FALSE, quiet = TRUE)
  close(con)
  return(content)
}

# Helper function to write to the OS X clipboard
# Adapted from https://github.com/jennybc/reprex/blob/master/R/clipboard.R
osx_write_clip <- function(content, object_type, breaks, eos, return_new, ...) {
  .dots <- list(...)
  con <- pipe("pbcopy")
  
  write_nix(content, object_type, breaks, eos, return_new, con, .dots)
}

# The same content rendering and writing steps are used in both OS X and Linux,
# just with different connection objects
write_nix <- function(content, object_type, breaks, eos, return_new, con, .dots) {
  # If no custom line separator has been specified, use Unix's default newline
  # character '\n'
  breaks <- ifelse(is.null(breaks), '\n', breaks)
  
  # If no custom tab separator for tables has been specified, use Unix's default
  # tab character: '\t'
  .dots$sep <- ifelse(is.null(.dots$sep), '\t', .dots$sep)
  
  # Pass the object to rendering functions before writing out to the clipboard
  rendered_content <- render_object(content, object_type, breaks, .dots)
  
  # Suppress pipe() warning when writing an empty string with a NULL string
  # ending.
  if (identical(rendered_content, "")) {
    suppressWarnings(writeChar(rendered_content, con = con, eos = eos))
  } else {
    writeChar(rendered_content, con = con, eos = eos)
  }
  
  close(con)
  
  if (return_new) {
    rendered_content
  } else {
    content
  }
}


# Helper function to read from the Windows clipboard
win_read_clip <- function() {
  utils::readClipboard()
}

# Helper function to write to the Windows clipboard
win_write_clip <- function(content, object_type, breaks, eos, return_new, ...) {
  
  .dots <- list(...)
  
  # If no custom line separator has been specified, use Windows's default
  # newline character '\r\n'
  breaks <- ifelse(is.null(breaks), '\r\n', breaks)
  
  # If no custom tab separator for tables has been specified, use Windows's
  # default tab character: '\t'
  .dots$sep <- ifelse(is.null(.dots$sep), '\t', .dots$sep)
  
  # Pass the object to rendering functions before writing out to the clipboard
  rendered_content <- render_object(content, object_type, breaks, .dots)
  utils::writeClipboard(rendered_content, format = 1)
  if (return_new) {
    rendered_content
  } else {
    content
  }
}


# Determine if a given utility is installed AND accessible
# Takes a character vector whose first element is the name of the
# utility executable and whose subsequent elements are command-line
# arguments to the utility for the test run.
has_util <- function(util_test) {
  if (nzchar(Sys.which(util_test[1]))) {
    # If utility is accessible, check that DISPLAY can be opened.
    try_res <- tryCatch(system2(util_test[1], util_test[-1], stdout = TRUE, stderr = TRUE),
                        error = function(c) FALSE,
                        warning = function(c) FALSE)
    
    # In the case of an error/warning on trying the function, then the util is
    # not available
    if (identical(try_res, FALSE)) {
      notify_no_display()
    } else {
      TRUE
    }
  } else {
    FALSE
  }
}

# Determine if system has 'xclip' installed AND it's accessible
has_xclip <- function() has_util(c("xclip", "-o", "-selection", "clipboard"))

# Determine if system has 'xsel' installed
has_xsel <- function() has_util(c("xsel", "--clipboard"))

# Stop read/write and return an error of missing clipboard software.
notify_no_cb <- function() {
  stop(msg_no_clipboard(), call. = FALSE)
}

notify_no_display <- function() {
  stop(msg_no_display(), call. = FALSE)
}

# Helper function to read from the X11 clipboard
#
# Requires the utility 'xclip' or 'xsel'. This function will stop with an error
# if neither is found. Adapted from:
# https://github.com/mrdwab/overflow-mrdwab/blob/master/R/readClip.R and:
# https://github.com/jennybc/reprex/blob/master/R/clipboard.R
X11_read_clip <- function() {
  if (has_xclip()) {
    con <- pipe("xclip -o -selection clipboard")
  } else if (has_xsel()) {
    con <- pipe("xsel --clipboard")
  } else {
    notify_no_cb()
  }
  content <- scan(con, what = character(), sep = "\n",
                  blank.lines.skip = FALSE, quiet = TRUE)
  close(con)
  return(content)
}

# Helper function to write to the X11 clipboard
#
# Requires the utility 'xclip' or 'xsel'. This function will stop with an error
# if neither is found. Adapted from
# https://github.com/mrdwab/overflow-mrdwab/blob/master/R/writeClip.R
#
# Targets "primary" and "clipboard" clipboards if using xclip, see:
# http://unix.stackexchange.com/a/69134/89254
X11_write_clip <- function(content, object_type, breaks, eos, return_new, ...) {
  if (has_xclip()) {
    con <- pipe("xclip -i -sel p -f | xclip -i -sel c", "w")
  } else if (has_xsel()) {
    con <- pipe("xsel -b -i", "w")
  } else {
    notify_no_cb()
  }
  
  .dots <- list(...)
  
  write_nix(content, object_type, breaks, eos, return_new, con, .dots)
}

.onAttach <- function(libname, pkgname) {
  packageStartupMessage("Welcome to clipr. See ?write_clip for advisories on writing to the clipboard in R.")
}

# Determine system type
sys_type <- function() {
  return(Sys.info()["sysname"])
}

#' Is the system clipboard available?
#'
#' Checks to see if the system clipboard is write-able/read-able. This may be
#' useful if you are developing a package that relies on clipr and need
#' to ensure that it will skip tests on machines (e.g. CRAN, Travis) where
#' the system clipboard may not be available.
#'
#' If you are trying to call this in a non-interactive session, be sure to call
#' using `clipr_available(allow_non_interactive = TRUE)`, or by setting the
#' environment variable `CLIPBOARD_AVAILABLE=TRUE`
#'
#' @param \ldots Pass other options to [`write_clip()`]. Generally only used to
#'   pass the argument `allow_non_interactive_use = TRUE`.
#'
#' @return `clipr_available` returns a boolean value.
#'
#' @examples
#' \dontrun{
#' # When using testthat:
#' library(testthat)
#' skip_if_not(clipr_available())
#' }
#'
#' @export
clipr_available <- function(...) {
  clipr_results_check(clipr_available_handler(...))
}

#' @rdname clipr_available
#'
#' @return Prints an informative message to the console with
#'   software and system configuration requirements if clipr is not available
#'   (invisibly returns the same string)
#'
#' @export
dr_clipr <- function(...) {
  res <- clipr_available_handler(...)
  
  if (clipr_results_check(res)) {
    msg <- msg_clipr_available()
  } else {
    msg <- attr(res$write, which = "condition", exact = TRUE)$message
  }
  
  message(msg)
  invisible(msg)
}

clipr_available_handler <- function(...) {
  suppressWarnings({
    read_attempt <- try(read_clip(...), silent = TRUE)
    write_attempt <- try(write_clip(read_attempt, ...), silent = TRUE)
  })
  return(list(read = read_attempt, write = write_attempt))
}

clipr_results_check <- function(res) {
  if (inherits(res$read, "try-error")) {
    return(FALSE)
  }
  
  if (inherits(res$write, "try-error")) {
    return(FALSE)
  }
  TRUE
}

msg_clipr_available <- function() "clipr has read/write access to the system clipboard!"

msg_no_clipboard <- function() "Clipboard on X11 requires 'xclip' (recommended) or 'xsel'."

msg_no_display <- function() "Clipboard on X11 requires that the DISPLAY envvar be configured."

msg_interactive <- function() "To run write_clip() in non-interactive mode, either call write_clip() with allow_non_interactive = TRUE, or set the environment variable CLIPR_ALLOW=TRUE"

warn_interactive <- function() {
  stop(msg_interactive())
}

